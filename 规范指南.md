####　type(数据类型)
* 基本类型： string boole Number null undefind
	* 直接存取基本类型值。
* 复杂类型： Object Array funciton
	* 通过引用的方式存取复杂类型值
#### References (变量引用)
* 所有的变量引用使用const,避免使用var

	```javascript
	why? 这是确保避免你引用的变量重复赋值，这样容易导致bug和使代码难以理解。我的理解是:使用var声明变量是在全局作用域中，很容易被覆盖修改，在es6中变量在块级作用域中才生效，所以我们应该遵循这种原则，即使需要重新赋值也是使用let,而不是使用var。下面两点有提到。
	```
* If you must reassign references, use let instead of var. 
*  Note that both let and const are block-scoped.
#### Objects 
* 使用字面量来创建对象，不用new来创建对象

	```javascript
	 why? 我的理解是：通过new Object()来创建对象其实是实例化构造函数(constructor),等价与{};但底层处理了一些事，比如构造函数实例化，改变this的指向，所以直接用字面量创建对象应该性能更好，同理数组也一样。
	```
* Use computed property names when creating objects with dynamic property names.（用动态属性命名创建一个对象时，应该使用已计算好的属性命名？） 简单说就是直接在对象{}里面定义一个属性，不要在外面追加。
* 使用对象的简写(缩写)模式
* 使用属性值简写,
* 在对象字面量开始就放那些简写的属性。因为它很容易就告诉了我们使用了哪些简写的属性
* 只有引号属性是无效标示时，eslint应该配置quote-props: ["error", "as-needed"]
* 不要直接调用Object.prototype,像hasOwnProperty(是否存在自有属性)、propertyIsEnumerable(属性是否可枚举),isPrototypeOf(实例对象是否在另一对象的原型链中)

	```javascript
	 why: 这个方法可能存在性能问题，比如hasOwnProperty作为对象的一个属性{hasOwnProperty:false}或者创建一个空对象Object.create(null)
	```

* 通过Object.assign()来浅拷贝一个对象宁愿用操作符(...)，？？？不是很理解，MDA上面基本上是第二种。
#### Array
* 同样适用字面量语法创建数组，不要用new的方式
* 使用数组的push的方式来追加元素，来代替直接赋值的方式。
* 使用扩展运位符来复制数组，不要用循环方式，(有谁会这么干？直接赋值或concat都行啊)
* 使用 Array.from来将类数组对象转换成数组 

		```javascript	
		举个栗子：
		function toArray(){
			return Array.prototype.slice.call(arguments) // es5
			// Array.from(arguments) es6的方式
		}
		toArray('a','b','c') // ['a','b','c']
		```
* 在数组的回调方法中使用return语句，如果在function里面是单个语句可以省略return。
#### Destructuring
* 当访问和使用一个对象的多个属性时，使用对象的解构方法，因为解构方式省去了创建临时引用属性(变量)。
* 使用数组解构方式，同样可以省去创建临时变量
* 要返回多个值时使用对象解构，不要使用数组解构。因为使用数组解构调用时候要考虑返回数据的顺序，而使用对象只要选择需要的数据就行。
#### string 
* 使用单引号字符串
* 超过100字节的字符串不要打断。
* 通过编程建立字符串时，使用字符串模板来替拼接方式。
* 永远不要使用eval()方法来处理字符串，它有太多的性能和安全漏洞，处理字符串对象或字符串json时，使用eval()一定是不合理的，肯定有代替它的方法。
* 字符串里不要有不必要的转义字符。
#### Functions 
* 使用命名的函数表达式替代函数声明的方式

	```javascript
		函数声明提前，在定义之前很函数很容易被引用，这会影响可读性和可维护性。
		如果一个函数很大或很复杂，干扰你理解其他部分，可以封装自己的模块，但是不要忘了名字的描述。匿名函数在错误的调用堆栈很难找到问题。todo?
	```
* 匿名函数自执行(IIFE)
*  永远不要在一个（if、while、etc）非函数代码块中声明一个函数，应该把那个函数赋给一个变量。浏览器允许你这么做，但它们的解析表现不一致
*  注意: ECMA-262 把 block 定义为一组语句。函数声明不是语句。(对上一点的解释)
*  永远不要用arguments命名参数，这会把原来函数的arguments类数组对象替换掉
*  不要用arguments形式传参，要用rest语法...形式

	```javascript	
	因为使用 ... 能明确你要传入的参数。另外 rest 参数是一个真正的数组，而 arguments 是一个类数组。
	```
* 使用默认参数的语法而不要改变函数的arguments
* 直接给函数参数赋值时需要避免副作用。
* 默认的参数应该总是放在最后面
* 永远不要使用new的方式(Function构造函数)创建一个函数
* 函数名用空格来前后隔开
* 不要改变参数
	
		```javascript
		// bad
		function f1(obj) {
		  obj.key = 1;
		}
		
		// good
		function f2(obj) {
		  const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1;
		}
		// 我认为用Object.assion()也行
		function foo(opts={}) {
		  Object.assign(opts,{key:1});
		  return opts;
		}
		//bad
		function f2(a) {
		  if (!a) { a = 1; }
		  // ...
		}
		// good
		function f4(a = 1) {
		  // ...
		}	
		```
* 使用扩展操作符...来回调可变的方法
 		
		（todo）es6中变量不能重复声明，所以不能直接console.log(x),用...相对apply方式更加简单
		// bad
		const x = [1, 2, 3, 4, 5];
		console.log.apply(console, x);
		
		// good
		const x = [1, 2, 3, 4, 5];
		console.log(...x);
	
* 函数参数多行的情况,或者调用,应该缩进。就像这个指南里的每一个多行list，每一项跟在逗号后面与上一条线对齐。	